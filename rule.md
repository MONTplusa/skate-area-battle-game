# skate-area-battle-game

## 概要

あなたは各マスに数字が書かれた$N \times N$のスケートリンクで 1vs1 の陣取り合戦をしている。
はじめ、あなたはグリッド上のある座標におり、相手は点対称の位置に存在する。
各ターン、どちらかのプレイヤーは自身が今いるところを岩石に変え、上下左右のいずれかのほうへ岩石(と相手プレイヤー)にぶつからない限り好きなだけ移動できる。（必ず動く必要がある）その際通過したマス及び自分が止まったマスは自分の色が塗られる。
基本的に交互に着手してゆくが、一方のプレイヤーが動けない場合そのプレイヤーの行動はパスされる。
両方が動けなくなったタイミングでゲーム終了である。この時、各プレイヤーが塗っているマスの数字の総和の大小で勝敗が決まる。
各プレイヤーが岩石に変えたマスも得点計算に含まれる。

## 入力生成

- $N=20$
- $A_{i,j}$: (i,j)に書かれた数字。0 以上 100 以下の整数から等確率で選出する。
- $x,y$: 先手プレイヤーの位置。$0 \leq x\leq N, 0 \leq y\leq N$のうち等確率で選出する

## GameState 構造体

GameState は以下の情報を有する。

- 各マスの数字を格納した二次元配列
- 各マスの色状態を格納した二次元配列 // どちらにも属していなければ-1
- 各マスの岩石設置状態を格納した二次元配列
- プレイヤー 0、プレイヤー 1 の座標
- 現在の手番

## AI interface に求められるメソッド

- selectBoard(gameStates []\*GameState) int
  　先手後手の緩和のため、最初に入力パターンが NUM_SAMPLE 個用意される。先手後手の決定権がない側はそれらのうちどの入力を採用するか決定する。
- selectTurn(gameStates []\*GameState)int
  　先手後手の決定権を持つ側が、選ばれた入力パターンに対して先手(0)または後手(1)を選ぶ。
- evaluate(gameState \*GameState, player int)float64
  　自分が行動を適用した後の盤面をもらい、その評価値を返す関数。

## ゲームの進行

- 入力パターンを NUM_SAMPLE 個用意し、ランダムに選んだ側の AI に入力採用権を与える。
- 決定した入力パターンに対して、もう一方のプレイヤーに先手後手を決めさせる。
- このターンでできるすべての行動を試す。各行動を適用した結果を対応する AI に evaluate させ、評価値が最大の行動を採用する
- 両者が動けなくなるまで続ける
- このゲーム結果をビジュアライズするための出力を生成する（将棋の棋譜のようなもの）
