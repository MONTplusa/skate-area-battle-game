import torch
import os
from pv_model import PVModel

# ---------- paths & hyperparams ----------
PT_PATH = 'mcts_policy_value_model.pt'
GO_OUT  = '../pkg/ai/monntplusa/cnn_weights.go'
BOARD   = 20
IN_CH   = 5
RES_BLK = 3
FILT    = 8
MAX_ST  = 20

# ---------- helper: Go literal generator ----------
def to_go_literal(obj, indent=0):
    sp = ' ' * indent
    if isinstance(obj, list):
        if len(obj) == 0:
            return '[]'
        parts = ['{']
        for i, el in enumerate(obj):
            lit = to_go_literal(el, indent + 4)
            comma = ','
            parts.append(f"{sp}    {lit}{comma}")
        parts.append(f"{sp}"+"}")
        return '\n'.join(parts)
    # scalar
    return f"{obj:.6f}"

# ---------- export ----------
if __name__ == '__main__':
    model = PVModel(board_size=BOARD, in_channels=IN_CH,
                    num_res_blocks=RES_BLK, filter_size=FILT,
                    max_steps=MAX_ST)
    model.load_state_dict(torch.load(PT_PATH, map_location='cpu'))
    model.eval()

    arrays = {}

    # ConvPre
    arrays['ConvPreW'] = model.conv_pre[0].weight.detach().cpu().numpy().tolist()
    arrays['ConvPreB'] = model.conv_pre[0].bias.detach().cpu().numpy().tolist()

    # Residual blocks aggregated
    res_w1, res_b1, res_w2, res_b2 = [], [], [], []
    for rb in model.res_blocks:
        res_w1.append(rb.conv1.weight.detach().cpu().numpy().tolist())
        res_b1.append(rb.conv1.bias.detach().cpu().numpy().tolist())
        res_w2.append(rb.conv2.weight.detach().cpu().numpy().tolist())
        res_b2.append(rb.conv2.bias.detach().cpu().numpy().tolist())
    arrays['ResWeights1'] = res_w1  # shape [B][F][F][3][3]
    arrays['ResBias1']    = res_b1  # shape [B][F]
    arrays['ResWeights2'] = res_w2
    arrays['ResBias2']    = res_b2

    # Value head 1x1 conv
    arrays['ValW'] = model.value_conv[0].weight.detach().cpu().numpy().tolist()
    arrays['ValB'] = model.value_conv[0].bias.detach().cpu().numpy().tolist()

    # FC layers
    arrays['ValFC1W'] = model.value_fc[0].weight.detach().cpu().numpy().tolist()
    arrays['ValFC1B'] = model.value_fc[0].bias.detach().cpu().numpy().tolist()
    arrays['ValFC2W'] = model.value_fc[2].weight.detach().cpu().numpy().tolist()[0]
    arrays['ValFC2B'] = model.value_fc[2].bias.detach().cpu().numpy().tolist()[0]

    # ---------- write Go file ----------
    os.makedirs(os.path.dirname(GO_OUT), exist_ok=True)
    with open(GO_OUT, 'w') as f:
        f.write('// Code generated by export_cnn_go.py; DO NOT EDIT.\n')
        f.write('package monntplusa\n\n')
        for name, arr in arrays.items():
            # determine depth
            depth = 0; tmp = arr
            while isinstance(tmp, list):
                depth += 1
                tmp = tmp[0] if tmp else None
            go_type = 'float64'
            for _ in range(depth):
                go_type = '[]' + go_type
            lit = to_go_literal(arr)
            f.write(f'var {name} = {go_type}{lit}\n\n')
    print('Generated', GO_OUT)
