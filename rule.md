# skate-area-battle-game

## 概要

あなたは各マスに数字が書かれた$N \times N$のスケートリンクで 1vs1 の陣取り合戦をしている。
はじめ、あなたはグリッド上のある座標におり、相手は点対称の位置に存在する。
各ターン、手番のプレイヤーは自身が今いるところを岩石に変え、上下左右のいずれかのほうへ岩石(と相手プレイヤー)にぶつからない限り好きなだけ移動できる（必ず動く必要がある）。その際通過したマス及び移動前のマス、移動後のマスは自分の色が塗られる。
基本的に交互に着手してゆくが、一方のプレイヤーが動けない場合そのプレイヤーの行動はパスされる。
両方が動けなくなったタイミングでゲーム終了である。この時、各プレイヤーが塗っているマスの数字の総和の大小で勝敗が決まる。
各プレイヤーが岩石に変えたマスも得点計算に含まれる。

## 入力生成

- $N=20$
- $A_{i,j}$: (i,j)に書かれた数字。0 以上 100 以下の整数から等確率で選出する。
- $x,y$: 先手プレイヤーの位置。$0 \leq x\leq N, 0 \leq y\leq N$のうち等確率で選出する。ユークリッド距離の二乗が$N$以下の場合は生成をやり直す。

## GameState 構造体

GameState は以下の情報を有する。詳細は state.go 参照。

- 各マスの数字を格納した二次元配列
- 各マスの色状態を格納した二次元配列 // どちらにも属していなければ-1
- 各マスの岩石設置状態を格納した二次元配列
- プレイヤー 0、プレイヤー 1 の座標
- 現在の手番

## AI interface に求められるメソッド

- selectBoard(gameStates []\*GameState) int
  先手後手の緩和のため、最初に入力パターンが NUM_SAMPLE 個用意される。先手後手の決定権がない側はそれらのうちどの入力を採用するか決定する。
- selectTurn(gameStates []\*GameState)int
  先手後手の決定権を持つ側が、選ばれた入力パターンに対して先手(0)または後手(1)を選ぶ。
- evaluate(gameState \*GameState, player int)float64
  自分が行動を適用した後の盤面をもらう。その盤面に対し評価値を返す。
- getName() string
  AI の名称を返す。特に理由がない限り package 名・フォルダ名から乖離した名称を使用しない。

また、メソッドのほかに、AI 登録のために New()が必要である。random,trivial の例を参照

## ゲームの進行

- 入力パターンを NUM_SAMPLE 個用意し、ランダムに選んだ側の AI に入力採用権を与える。
- 決定した入力パターンに対して、もう一方のプレイヤーに先手後手を決めさせる。(暫定的に player0 が先手位置、player1 が後手位置として与えられており、先手後手の決定に応じて自身の初期位置が決定される。)
- このターンでできるすべての行動を試す。各行動を適用した結果を対応する AI に evaluate させ、評価値が最大の行動を採用する
- 両者が動けなくなるまで続ける
- このゲーム結果をビジュアライズする
